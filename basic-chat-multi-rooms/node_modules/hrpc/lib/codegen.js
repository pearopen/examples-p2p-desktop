const primitives = require('hyperschema/primitives')

module.exports = function generateCode(hrpc, { esm = false }) {
  let str = ''
  str += '// This file is autogenerated by the hrpc compiler\n'
  str += '/* eslint-disable camelcase */\n'
  str += '/* eslint-disable space-before-function-paren */\n'
  str += '\n'

  if (esm) {
    str +=
      "import { c, RPC, RPCStream, RPCRequestStream } from 'hrpc/runtime'\n"
    str += "import { getEncoding } from './messages.js'\n"
  } else {
    str +=
      "const { c, RPC, RPCStream, RPCRequestStream } = require('hrpc/runtime')\n"
    str += "const { getEncoding } = require('./messages.js')\n"
  }
  str += '\n'
  str += 'const methods = new Map([\n'
  hrpc.handlers.forEach((e, i) => {
    if (i < hrpc.handlers.length - 1) {
      str += `  ['${e.name}', ${i}],\n`
      str += `  [${i}, '${e.name}'],\n`
    } else {
      str += `  ['${e.name}', ${i}],\n`
      str += `  [${i}, '${e.name}']\n`
    }
  })
  str += '])\n'
  str += '\n'
  str += 'class HRPC {\n'
  str += '  constructor(stream) {\n'
  str += '    this._stream = stream\n'
  str += '    this._handlers = []\n'
  str += '    this._requestEncodings = new Map([\n'
  hrpc.handlers.forEach((e, i) => {
    if (i < hrpc.handlers.length - 1) {
      str += `      ['${e.name}', ${getEncoding(e.request.name)}],\n`
    } else {
      str += `      ['${e.name}', ${getEncoding(e.request.name)}]\n`
    }
  })
  str += '    ])\n'
  str += '    this._responseEncodings = new Map([\n'
  hrpc.handlers
    .filter((e) => !!e.response)
    .forEach((e, i, arr) => {
      if (i < arr.length - 1) {
        str += `      ['${e.name}', ${getEncoding(e.response.name)}],\n`
      } else {
        str += `      ['${e.name}', ${getEncoding(e.response.name)}]\n`
      }
    })
  str += '    ])\n'
  str += '    this._rpc = new RPC(stream, async (req) => {\n'
  str += '      const command = methods.get(req.command)\n'
  str += '      const responseEncoding = this._responseEncodings.get(command)\n'
  str += '      const requestEncoding = this._requestEncodings.get(command)\n'
  str += '      if (this._requestIsSend(command)) {\n'
  str +=
    '        const request = req.data ? c.decode(requestEncoding, req.data) : null\n'
  str += '        await this._handlers[command](request)\n'
  str += '        return\n'
  str += '      }\n'
  str +=
    '      if (!this._requestIsStream(command) && !this._responseIsStream(command)) {\n'
  str +=
    '        const request = req.data ? c.decode(requestEncoding, req.data) : null\n'
  str += '        const response = await this._handlers[command](request)\n'
  str += '        req.reply(c.encode(responseEncoding, response))\n'
  str += '      }\n'
  str +=
    '      if (!this._requestIsStream(command) && this._responseIsStream(command)) {\n'
  str +=
    '        const request = req.data ? c.decode(requestEncoding, req.data) : null\n'
  str += '        const responseStream = new RPCStream(\n'
  str += '          null,\n'
  str += '          null,\n'
  str += '          req.createResponseStream(),\n'
  str += '          responseEncoding\n'
  str += '        )\n'
  str += '        responseStream.data = request\n'
  str += '        await this._handlers[command](responseStream)\n'
  str += '      }\n'
  str +=
    '      if (this._requestIsStream(command) && !this._responseIsStream(command)) {\n'
  str += '        const requestStream = new RPCRequestStream(\n'
  str += '          req,\n'
  str += '          responseEncoding,\n'
  str += '          req.createRequestStream(),\n'
  str += '          requestEncoding\n'
  str += '        )\n'
  str +=
    '        const response = await this._handlers[command](requestStream)\n'
  str += '        req.reply(c.encode(responseEncoding, response))\n'
  str += '      }\n'
  str +=
    '      if (this._requestIsStream(command) && this._responseIsStream(command)) {\n'
  str += '        const requestStream = new RPCRequestStream(\n'
  str += '          req,\n'
  str += '          responseEncoding,\n'
  str += '          req.createRequestStream(),\n'
  str += '          requestEncoding,\n'
  str += '          req.createResponseStream(),\n'
  str += '          responseEncoding\n'
  str += '        )\n'
  str += '        await this._handlers[command](requestStream)\n'
  str += '      }\n'
  str += '    })\n'
  str += '  }\n'
  str += '\n'
  str += '  async _call(name, args) {\n'
  str += '    const requestEncoding = this._requestEncodings.get(name)\n'
  str += '    const responseEncoding = this._responseEncodings.get(name)\n'
  str += '    const request = this._rpc.request(methods.get(name))\n'
  str += '    const encoded = c.encode(requestEncoding, args)\n'
  str += '    request.send(encoded)\n'
  str += '    return c.decode(responseEncoding, await request.reply())\n'
  str += '  }\n'
  str += '\n'
  str += '  _callSync(name, args) {\n'
  str += '    const requestEncoding = this._requestEncodings.get(name)\n'
  str += '    const responseEncoding = this._responseEncodings.get(name)\n'
  str += '    if (this._requestIsSend(name)) {\n'
  str += '      const encoded = c.encode(requestEncoding, args)\n'
  str += '      const request = this._rpc.event(methods.get(name))\n'
  str += '      request.send(encoded)\n'
  str += '    }\n'
  str += '\n'
  str += '    const request = this._rpc.request(methods.get(name))\n'
  str += '\n'
  str +=
    '    if (!this._requestIsStream(name) && this._responseIsStream(name)) {\n'
  str += '      const encoded = c.encode(requestEncoding, args)\n'
  str += '      request.send(encoded)\n'
  str +=
    '      return new RPCStream(request.createResponseStream(), responseEncoding)\n'
  str += '    }\n'
  str +=
    '    if (this._requestIsStream(name) && !this._responseIsStream(name)) {\n'
  str += '      return new RPCRequestStream(\n'
  str += '        request,\n'
  str += '        responseEncoding,\n'
  str += '        null,\n'
  str += '        null,\n'
  str += '        request.createRequestStream(),\n'
  str += '        requestEncoding\n'
  str += '      )\n'
  str += '    }\n'
  str +=
    '    if (this._requestIsStream(name) && this._responseIsStream(name)) {\n'
  str += '      return new RPCRequestStream(\n'
  str += '        request,\n'
  str += '        responseEncoding,\n'
  str += '        request.createResponseStream(),\n'
  str += '        responseEncoding,\n'
  str += '        request.createRequestStream(),\n'
  str += '        requestEncoding\n'
  str += '      )\n'
  str += '    }\n'
  str += '  }\n'
  str += '\n'
  hrpc.handlers.forEach((e) => {
    const returnsStream =
      e.response?.stream || e.request.stream || e.request.send
    str += `  ${returnsStream ? '' : 'async '}${convertToCamelCase(e.name)}(args) {\n`
    str += `    return this.${returnsStream ? '_callSync' : '_call'}('${e.name}', args)\n`
    str += '  }\n'
    str += '\n'
  })
  hrpc.handlers.forEach((e) => {
    str += `  ${convertToCamelCase(e.name, { prefix: 'on' })}(responseFn) {\n`
    str += `    this._handlers['${e.name}'] = responseFn\n`
    str += '  }\n'
    str += '\n'
  })
  str += '  _requestIsStream(command) {\n'
  str += '    return [\n'
  hrpc.handlers
    .filter((e) => e.request.stream === true)
    .forEach((e, i, arr) => {
      if (i < arr.length - 1) {
        str += `      '${e.name}',\n`
      } else {
        str += `      '${e.name}'\n`
      }
    })
  str += '    ].includes(command)\n'
  str += '  }\n'
  str += '\n'
  str += '  _responseIsStream(command) {\n'
  str += '    return [\n'
  hrpc.handlers
    .filter((e) => e.response?.stream === true)
    .forEach((e, i, arr) => {
      if (i < arr.length - 1) {
        str += `      '${e.name}',\n`
      } else {
        str += `      '${e.name}'\n`
      }
    })
  str += '    ].includes(command)\n'
  str += '  }\n'
  str += '\n'
  str += '  // prettier-ignore-start\n'
  str += '  _requestIsSend(command) {\n'
  str += '    return [\n'
  str += '      // prettier-ignore\n'
  hrpc.handlers
    .filter((e) => e.request.send === true)
    .forEach((e, i, arr) => {
      if (i < arr.length - 1) {
        str += `      '${e.name}',\n`
      } else {
        str += `      '${e.name}'\n`
      }
    })
  str += '    ].includes(command)\n'
  str += '  }\n'
  str += '}\n\n'

  if (esm) {
    str += 'export default HRPC\n'
  } else {
    str += 'module.exports = HRPC\n'
  }

  return str
}

function convertToCamelCase(input, opts = { prefix: '' }) {
  if (input.startsWith('@')) {
    input = input.slice(input.indexOf('/') + 1)
  }

  const parts = input.split(/[/-]/)

  const camelCased = parts.map((part, index) => {
    if (index === 0 && opts.prefix.length === 0) return part
    return part.charAt(0).toUpperCase() + part.slice(1)
  })

  return opts.prefix + camelCased.join('')
}

function getEncoding(s) {
  return primitives.has(s) ? `c.${s}` : `getEncoding('${s}')`
}
